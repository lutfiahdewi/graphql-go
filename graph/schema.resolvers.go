package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"fmt"
	"strconv"
	// "log"

	"github.com/lutfiahdewi/graphql-go/graph/model"
	"github.com/lutfiahdewi/graphql-go/internal/auth"
	"github.com/lutfiahdewi/graphql-go/internal/kegiatans"
	"github.com/lutfiahdewi/graphql-go/internal/tKegSurveis"
	"github.com/lutfiahdewi/graphql-go/internal/users"
	"github.com/lutfiahdewi/graphql-go/pkg/jwt"
)

// CreateLink is the resolver for the createLink field.
func (r *mutationResolver) CreateKegiatan(ctx context.Context, input model.NewKegiatan) (*model.Kegiatan, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return &model.Kegiatan{}, fmt.Errorf("access denied")
	}

	var kegiatan kegiatans.Kegiatan
	kegiatan.Title = input.Title
	kegiatan.Status = input.Status
	kegiatan.User = user
	graphqlUser := &model.User{
		ID:   user.ID,
		Name: user.Username,
	}
	/*kegiatan.User.ID = "4"
	kegiatan.User.Username = "user dummy"
	kegiatan.User.Password = "pswd123"*/
	// kegiatan.User = &users.User{ID: "4", Username: "User Dummy"}
	var id int64 = kegiatan.Create() //should re-query the inserted row(??)
	return &model.Kegiatan{ID: strconv.FormatInt(id, 10), Title: kegiatan.Title, Status: kegiatan.Status, User: graphqlUser}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (string, error) {
	var user users.User
	user.Username = input.Username
	user.Password = input.Password
	user.Create()
	token, err := jwt.GenerateToken(user.Username)
	if err != nil {
		return "", err
	}
	return token, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.Login) (string, error) {
	var user users.User
	user.Username = input.Username
	user.Password = input.Password
	correct := user.Authenticate()
	if !correct {
		// 1
		return "", &users.WrongUsernameOrPasswordError{}
	}
	token, err := jwt.GenerateToken(user.Username)
	if err != nil {
		return "", err
	}
	return token, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (string, error) {
	username, err := jwt.ParseToken(input.Token)
	if err != nil {
		return "", fmt.Errorf("access denied")
	}
	token, err := jwt.GenerateToken(username)
	if err != nil {
		return "", err
	}
	return token, nil
}

// CreateTKegSurvei is the resolver for the createTKegSurvei field.
func (r *mutationResolver) CreateTKegSurvei(ctx context.Context, input model.NewTKegSurvei) (*model.TKegSurvei, error) {
	/*user := auth.ForContext(ctx)
	if user == nil {
		return &model.TKegSurvei{}, fmt.Errorf("access denied")
	}*/
	var tKegSurvei tKegSurveis.TKegSurvei
	tKegSurvei.Survei_kd = input.SurveiKd
	tKegSurvei.Keg_kd = input.KegKd
	tKegSurvei.Status = input.Status
	tKegSurvei.Tgl_buka = *input.TglBuka
	tKegSurvei.Tgl_rek_mulai = *input.TglRekMulai
	tKegSurvei.Tgl_rek_selesai = *input.TglRekSelesai
	tKegSurvei.Tgl_mulai = *input.TglMulai
	tKegSurvei.Tgl_selesai = *input.TglSelesai
	tKegSurvei.Is_multi = *input.IsMulti
	tKegSurvei.Is_rekrutmen = (*input.IsRekrutmen)
	tKegSurvei.Is_add_indicator = input.IsAddIndicator
	tKegSurvei.Is_confirm = input.IsConfirm
	tKegSurvei.Created_by = input.CreatedBy

	id := tKegSurvei.Create() //should re-query the inserted row(??)
	return &model.TKegSurvei{
		ID:             strconv.FormatInt(id, 10),
		SurveiKd:       tKegSurvei.Survei_kd,
		KegKd:          tKegSurvei.Keg_kd,
		Status:         tKegSurvei.Status,
		TglBuka:        &tKegSurvei.Tgl_buka,
		TglRekMulai:    &tKegSurvei.Tgl_rek_mulai,
		TglRekSelesai:  &tKegSurvei.Tgl_rek_selesai,
		TglMulai:       &tKegSurvei.Tgl_mulai,
		TglSelesai:     &tKegSurvei.Tgl_selesai,
		IsRekrutmen:    &tKegSurvei.Is_rekrutmen,
		IsMulti:        &tKegSurvei.Is_multi,
		IsConfirm:      tKegSurvei.Is_confirm,
		IsAddIndicator: tKegSurvei.Is_add_indicator,
		CreatedBy:      tKegSurvei.Created_by,
		// CreatedAt:      tKegSurvei.Created_at,
		// UpdatedBy:      tKegSurvei.Tgl_buka,
		// UpdatedAt:      tKegSurvei.Tgl_buka,
	}, nil
}

// EditTKegSurvei is the resolver for the editTKegSurvei field.
func (r *mutationResolver) EditTKegSurvei(ctx context.Context, input model.EditTKegSurvei) (*model.TKegSurvei, error) {
	panic(fmt.Errorf("not implemented: EditTKegSurvei - editTKegSurvei"))
}

// DeleteTKegSurvei is the resolver for the deleteTKegSurvei field.
func (r *mutationResolver) DeleteTKegSurvei(ctx context.Context, input string) (string, error) {
	panic(fmt.Errorf("not implemented: DeleteTKegSurvei - deleteTKegSurvei"))
}

// Kegiatan is the resolver for the Kegiatan field.
func (r *queryResolver) Kegiatan(ctx context.Context, input []string) ([]*model.Kegiatan, error) {
	panic(fmt.Errorf("not implemented: Kegiatan - Kegiatan"))
}

// Kegiatans is the resolver for the Kegiatans field.
func (r *queryResolver) Kegiatans(ctx context.Context) ([]*model.Kegiatan, error) {
	var resultKegiatans []*model.Kegiatan
	var dbKegiatans []kegiatans.Kegiatan = kegiatans.GetAll()
	for _, kegiatan := range dbKegiatans {
		graphqlUser := &model.User{
			ID:   kegiatan.User.ID,
			Name: kegiatan.User.Username,
		}
		resultKegiatans = append(resultKegiatans, &model.Kegiatan{ID: kegiatan.ID, Title: kegiatan.Title, Status: kegiatan.Status, User: graphqlUser})
	}
	return resultKegiatans, nil
}

// TKegSurvei is the resolver for the tKegSurvei field.
func (r *queryResolver) TKegSurvei(ctx context.Context) ([]*model.TKegSurvei, error) {
	panic(fmt.Errorf("not implemented: TKegSurvei - tKegSurvei"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }


